# Table of Contents

* [django\_rls](#django_rls)
* [django\_rls.admin](#django_rls.admin)
* [django\_rls.apps](#django_rls.apps)
* [django\_rls.constants](#django_rls.constants)
* [django\_rls.exceptions](#django_rls.exceptions)
* [django\_rls.management.commands.add\_rls](#django_rls.management.commands.add_rls)
* [django\_rls.management.commands.makemigrations](#django_rls.management.commands.makemigrations)
* [django\_rls.management.commands](#django_rls.management.commands)
* [django\_rls.management](#django_rls.management)
* [django\_rls.middleware](#django_rls.middleware)
  * [RLSMiddleware](#django_rls.middleware.RLSMiddleware)
* [django\_rls.migrations](#django_rls.migrations)
  * [RunDynamicSQL](#django_rls.migrations.RunDynamicSQL)
* [django\_rls.migration\_hook](#django_rls.migration_hook)
* [django\_rls.resolvers](#django_rls.resolvers)
  * [default\_request\_user\_resolver](#django_rls.resolvers.default_request_user_resolver)
  * [default\_rls\_bypass\_check](#django_rls.resolvers.default_rls_bypass_check)
  * [strawberry\_context\_user\_resolver](#django_rls.resolvers.strawberry_context_user_resolver)
  * [strawberry\_rls\_bypass\_check](#django_rls.resolvers.strawberry_rls_bypass_check)
* [django\_rls.settings](#django_rls.settings)
* [django\_rls.settings\_type](#django_rls.settings_type)
  * [DjangoRLSSettings](#django_rls.settings_type.DjangoRLSSettings)
    * [RLS\_FIELDS](#django_rls.settings_type.DjangoRLSSettings.RLS_FIELDS)
    * [TENANT\_APPS](#django_rls.settings_type.DjangoRLSSettings.TENANT_APPS)
    * [REQUEST\_RESOLVER](#django_rls.settings_type.DjangoRLSSettings.REQUEST_RESOLVER)
    * [BYPASS\_CHECK\_RESOLVER](#django_rls.settings_type.DjangoRLSSettings.BYPASS_CHECK_RESOLVER)
    * [AUTO\_SET\_FIELDS](#django_rls.settings_type.DjangoRLSSettings.AUTO_SET_FIELDS)
    * [SKIP\_MODELS](#django_rls.settings_type.DjangoRLSSettings.SKIP_MODELS)
    * [SESSION\_NAMESPACE\_PREFIX](#django_rls.settings_type.DjangoRLSSettings.SESSION_NAMESPACE_PREFIX)
    * [USE\_DB\_MIGRATION\_USER](#django_rls.settings_type.DjangoRLSSettings.USE_DB_MIGRATION_USER)
    * [MIGRATION\_USER](#django_rls.settings_type.DjangoRLSSettings.MIGRATION_USER)
    * [MIGRATION\_PASSWORD](#django_rls.settings_type.DjangoRLSSettings.MIGRATION_PASSWORD)
* [django\_rls.utils](#django_rls.utils)
  * [get\_field\_sql\_type](#django_rls.utils.get_field_sql_type)
  * [build\_rls\_using\_clause](#django_rls.utils.build_rls_using_clause)

<a id="django_rls"></a>

# django\_rls

<a id="django_rls.admin"></a>

# django\_rls.admin

<a id="django_rls.apps"></a>

# django\_rls.apps

<a id="django_rls.constants"></a>

# django\_rls.constants

<a id="django_rls.exceptions"></a>

# django\_rls.exceptions

<a id="django_rls.management.commands.add_rls"></a>

# django\_rls.management.commands.add\_rls

<a id="django_rls.management.commands.makemigrations"></a>

# django\_rls.management.commands.makemigrations

<a id="django_rls.management.commands"></a>

# django\_rls.management.commands

<a id="django_rls.management"></a>

# django\_rls.management

<a id="django_rls.middleware"></a>

# django\_rls.middleware

<a id="django_rls.middleware.RLSMiddleware"></a>

## RLSMiddleware Objects

```python
class RLSMiddleware(MiddlewareMixin)
```

Middleware that sets PostgreSQL session variables based on RLS context.

- If BYPASS_CHECK_RESOLVER returns True, sets all session vars to RlsWildcard.ALL.
- Otherwise uses VALUE_RESOLVER to fetch per-field RLS values.
- Only sets session vars for fields in RLS_FIELDS.

These variables are used in PostgreSQL RLS policies with current_setting().

<a id="django_rls.migrations"></a>

# django\_rls.migrations

<a id="django_rls.migrations.RunDynamicSQL"></a>

## RunDynamicSQL Objects

```python
class RunDynamicSQL(Operation)
```

A custom migration operation that generates SQL at runtime.

This operation is used to create and drop RLS policies dynamically.
The SQL is generated by the provided functions at migration time,
allowing for dynamic table and policy name resolution.

**Arguments**:

- `create_func` - A callable that takes a schema_editor and returns SQL string
  to create the RLS policy.
- `drop_func` - A callable that takes a schema_editor and returns SQL string
  to drop the RLS policy.

<a id="django_rls.migration_hook"></a>

# django\_rls.migration\_hook

<a id="django_rls.resolvers"></a>

# django\_rls.resolvers

<a id="django_rls.resolvers.default_request_user_resolver"></a>

#### default\_request\_user\_resolver

```python
def default_request_user_resolver(request: Any) -> Dict[str, RLSValue]
```

Default RLS resolver for standard Django requests in REQUEST_RESOLVER.

Dynamically builds a dict based on the fields in RLS_FIELDS.
Extracts the value directly from request.user.{field} - fields must map exactly.

If user is not authenticated or a field doesn't exist, returns RlsWildcard.NONE for that field.

<a id="django_rls.resolvers.default_rls_bypass_check"></a>

#### default\_rls\_bypass\_check

```python
def default_rls_bypass_check(request: Any) -> bool
```

Returns True if the current request's user is a superuser.
Default for BYPASS_CHECK_RESOLVER.

<a id="django_rls.resolvers.strawberry_context_user_resolver"></a>

#### strawberry\_context\_user\_resolver

```python
def strawberry_context_user_resolver(info: Any) -> Dict[str, RLSValue]
```

Strawberry GraphQL version of the default resolver.

Reads info.context.user and resolves all RLS_FIELDS dynamically.
Fields must map exactly to user attributes - no fallback logic.

<a id="django_rls.resolvers.strawberry_rls_bypass_check"></a>

#### strawberry\_rls\_bypass\_check

```python
def strawberry_rls_bypass_check(info: Any) -> bool
```

Returns True if the info.context.user is a superuser.
Intended for use as a BYPASS_CHECK_RESOLVER.

<a id="django_rls.settings"></a>

# django\_rls.settings

<a id="django_rls.settings_type"></a>

# django\_rls.settings\_type

<a id="django_rls.settings_type.DjangoRLSSettings"></a>

## DjangoRLSSettings Objects

```python
@dataclass
class DjangoRLSSettings()
```

DjangoRLSSettings

Configuration for enabling PostgreSQL Row-Level Security (RLS)
across selected Django models, with enforcement scoped by model fields
and session variables.

This includes dynamic policy generation, session binding, and model auto-filling.

<a id="django_rls.settings_type.DjangoRLSSettings.RLS_FIELDS"></a>

#### RLS\_FIELDS

A list of field names to be set as PostgreSQL session variables.
These fields are extracted from the user/context by REQUEST_RESOLVER and set
as `rls.field_name` in the database session.

**Example**:

  RLS_FIELDS = ["tenant_id", "user_id"]

<a id="django_rls.settings_type.DjangoRLSSettings.TENANT_APPS"></a>

#### TENANT\_APPS

List of app labels where all models should be treated as tenant-specific.
When using `add_rls`, models in these apps will automatically default to using
`tenant_id` for RLS if the field exists.

<a id="django_rls.settings_type.DjangoRLSSettings.REQUEST_RESOLVER"></a>

#### REQUEST\_RESOLVER

A function that returns the current RLS context to set into PostgreSQL session variables.

Example return:
    {
        "user_id": 1,
        "tenant_id": 4,
        "public":true,
    }

This value is used for:
- Setting session variables like `SET rls.tenant_id = 123`
- Auto-filling fields on models if AUTO_SET_FIELDS = True

You can plug in a Django request-based or Strawberry GraphQL resolver here.

<a id="django_rls.settings_type.DjangoRLSSettings.BYPASS_CHECK_RESOLVER"></a>

#### BYPASS\_CHECK\_RESOLVER

Optional function to determine if RLS should be bypassed entirely for a request or context.

If this returns True, all fields in RLS_FIELDS will be set to RlsWildcard.ALL.

Example use case:
    - Allow superusers to bypass RLS enforcement
    - Allow specific IPs or roles to see all data

<a id="django_rls.settings_type.DjangoRLSSettings.AUTO_SET_FIELDS"></a>

#### AUTO\_SET\_FIELDS

If True, models in TENANT_APPS will have their RLS fields automatically
set on creation/save based on the current session context (as resolved by `REQUEST_RESOLVER`).

For example, if a model requires `tenant_id` and `user_id`, and the current session provides:
    {"tenant_id": 123, "user_id": 456}

Then calling `model.save()` will auto-fill these fields before validation (unless explicitly set).
This helps prevent accidental leaks or incomplete data in a multi-tenant system.

<a id="django_rls.settings_type.DjangoRLSSettings.SKIP_MODELS"></a>

#### SKIP\_MODELS

Optional list of model paths (e.g., `"app.Model"`) to explicitly exclude from AUTO_SET_FIELDS
even if they are in TENANT_APPS.

**Example**:

  SKIP_MODELS = [
  "core.AuditLog",
  "sessions.Session"
  ]

<a id="django_rls.settings_type.DjangoRLSSettings.SESSION_NAMESPACE_PREFIX"></a>

#### SESSION\_NAMESPACE\_PREFIX

Prefix for PostgreSQL session variables used in `current_setting()`.

Changing this will break existing RLS policies unless manually updated.

<a id="django_rls.settings_type.DjangoRLSSettings.USE_DB_MIGRATION_USER"></a>

#### USE\_DB\_MIGRATION\_USER

If True, migrations (and potentially startup checks) that apply RLS policies
will explicitly use the `MIGRATION_USER` and `MIGRATION_PASSWORD` credentials.

This ensures that runtime roles (used by the app) are properly enforced by RLS as they are not the owner of the RLS policy.

<a id="django_rls.settings_type.DjangoRLSSettings.MIGRATION_USER"></a>

#### MIGRATION\_USER

Username of the dedicated RLS-safe migration user.

This user must:
- Have sufficient privileges to create policies
- Be separate from the app's runtime role

<a id="django_rls.settings_type.DjangoRLSSettings.MIGRATION_PASSWORD"></a>

#### MIGRATION\_PASSWORD

Password for the MIGRATION_USER.

<a id="django_rls.utils"></a>

# django\_rls.utils

<a id="django_rls.utils.get_field_sql_type"></a>

#### get\_field\_sql\_type

```python
def get_field_sql_type(model: models.Model, field_name: str) -> str
```

Maps Django field types to PostgreSQL SQL types for RLS policy generation.

**Arguments**:

- `model` - The Django model instance
- `field_name` - Name of the field to get the SQL type for
  

**Returns**:

  PostgreSQL SQL type string (e.g., 'int', 'uuid', 'text')
  

**Raises**:

- `FieldDoesNotExist` - If the field does not exist on the model

<a id="django_rls.utils.build_rls_using_clause"></a>

#### build\_rls\_using\_clause

```python
def build_rls_using_clause(fields: List[str], field_types: Dict[str, str],
                           session_prefix: str) -> str
```

Constructs the RLS USING clause with wildcard and null handling for each field.

Each field is wrapped in a CASE statement that handles:
- NULL session variables (returns FALSE)
- Empty strings (returns FALSE)
- RlsWildcard.NONE (returns FALSE)
- RlsWildcard.ALL (returns TRUE - bypasses RLS)
- Normal values (compares field to session variable)

**Arguments**:

- `fields` - List of field names to include in the RLS policy
- `field_types` - Dictionary mapping field names to their PostgreSQL SQL types
- `session_prefix` - Prefix for session variables (typically "rls")
  

**Returns**:

  SQL string containing the USING clause for the RLS policy

